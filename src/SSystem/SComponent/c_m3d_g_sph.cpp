//
// Generated by dtk
// Translation Unit: c_m3d_g_sph.cpp
//

#include "SSystem/SComponent/c_m3d_g_sph.h"
#include "SSystem/SComponent/c_m3d.h"
#include "JSystem/JUtility/JUTAssert.h"
#include "float.h"

#define CHECK_FLOAT_RANGE(line, x) JUT_ASSERT(line, -1.0e32f < x && x < 1.0e32f);
#define CHECK_VEC3_RANGE(line, v) JUT_ASSERT(line, -1.0e32f < v.x && v.x < 1.0e32f && -1.0e32f < v.y && v.y < 1.0e32f && -1.0e32f < v.z && v.z < 1.0e32f)

#if VERSION > VERSION_DEMO
/* 8025238C-80252624       .text SetC__8cM3dGSphFRC4cXyz */
void cM3dGSph::SetC(const cXyz& p) {
    JUT_ASSERT(18, !isnan(p.x));
    JUT_ASSERT(19, !isnan(p.y));
    JUT_ASSERT(20, !isnan(p.z));
    CHECK_VEC3_RANGE(23, p);
    mCenter = p;
}

/* 80252624-80252750       .text SetR__8cM3dGSphFf */
void cM3dGSph::SetR(float r) {
    JUT_ASSERT(32, !isnan(r));
    CHECK_FLOAT_RANGE(33, r);
    mRadius = r;
}
#endif

/* 80252750-8025277C       .text cross__8cM3dGSphCFPC8cM3dGSphP4cXyz */
bool cM3dGSph::cross(const cM3dGSph* pOther, cXyz* pOut) const {
    return cM3d_Cross_SphSph(pOther, this, pOut);
}

/* 8025277C-802527AC       .text cross__8cM3dGSphCFPC8cM3dGCylP4cXyz */
bool cM3dGSph::cross(const cM3dGCyl* pOther, cXyz* pOut) const {
    f32 f;
    return cM3d_Cross_CylSph(pOther, this, pOut, &f);
}

/* 802527AC-802527D4       .text cross__8cM3dGSphCFPC8cM3dGSphPf */
bool cM3dGSph::cross(const cM3dGSph* pOther, f32* pOut) const {
    f32 f;
    return cM3d_Cross_SphSph(this, pOther, &f, pOut);
}
